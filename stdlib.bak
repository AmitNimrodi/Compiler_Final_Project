#lang racket
(define map
  (let ((null? null?)
	(car car) (cdr cdr)
	(cons cons) (apply apply))
    (letrec ((map-loop (lambda (f l . ls)
		     (if (null? l)
			 '() ; simplifying assumption: if l is empty, then ls is also empty
			 (if (null? ls)
			     (cons (f (car l)) (map-loop f (cdr l)))
			     (cons (apply f (car l) (map-loop car ls))
				   (apply map f (cdr l) (map-loop cdr ls))))))))
      map-loop)))

;(fold-left - 0 '(1 5 10)) ---> -16
(define fold-left
  (let ((null? null?)
        (car car) (cdr cdr)
        (apply apply))
    (letrec ((fold-left-loop (lambda (f acc l)
                              (if (null? l)
                                  acc
                                  (if (pair? l)
                                      (fold-left-loop f (f acc (car l)) (cdr l) )
                                      (fold-left-loop f (f acc l) '() )
                                      )))))
    fold-left-loop)))

;(fold-right - '(1 5 10) 0) ---> 6
(define fold-right
  (let ((null? null?)
        (car car) (cdr cdr)
        (apply apply))
    (letrec ((fold-right-loop (lambda (f l acc)
                            (if (null? l)
                                acc
                                (if (pair? l)
                                    (fold-right-loop f (cdr l) (f (car l) acc))
                                    (fold-right-loop f '() (f l acc))
                                 )))))
    fold-right-loop)))

;;tests:
;(cons* '()) ---> ()
;(cons* '(a b)) ---> (a b)
;(cons* 'a 'b 'c) ---> (a b . c)
;(cons* 'a 'b '(c d)) ---> (a b c d)
(define cons*
  (let ((null? null?)
        (car car) (cdr cdr)
        (apply apply))
    (letrec ((cons*-loop (lambda (el . ls)
                           (if (null? el)
                               ls
                               (if (null? ls)
                                   el
                                   (fold-right
                                      (lambda (x y)
                                        (if (null? y)
                                                x
                                        (if (pair? y)
                                            (cons x y)
                                            (cons x y))))
                                      el ls))))))
             cons*-loop)))


(define append
  (let ((null? null?)
	(fold-right fold-right)
	(cons cons))
    (lambda args
      (fold-right (lambda (e a)
		    (if (null? a)
			e
			(fold-right cons a e)))
		  '() args))))

(define list (lambda x x))

(define list? 
  (let ((null? null?)
	(pair? pair?)
	(cdr cdr))
    (letrec ((list?-loop (lambda (x)
			   (or (null? x)
			       (and (pair? x)
				    (list? (cdr x)))))))
      list?-loop)))

(define length
  (let ((fold-left fold-left)
	(+ +))
    (lambda (l)
      (fold-left (lambda (acc e) (+ acc 1)) 0 l))))
